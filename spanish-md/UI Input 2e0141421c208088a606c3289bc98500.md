# UI Input

Toca la parte de **Input en la UI**, es decir, cómo manejan la entrada los nodos **`Control`** con **`_gui_input(event)`** y cómo se integra con el resto del sistema de Input. No hay acceso a documentación externa en este momento, así que esta explicación se basa en conocimiento previo y no puede llevar citas exactas.

---

## **`_gui_input(event)`** en nodos Control

- Los nodos de interfaz (botones, paneles, sliders, etc.) heredan de **`Control`** y pueden implementar el método **`_gui_input(event)`**.
- Este método recibe eventos de entrada que ocurren “encima” de ese nodo (clic, rueda, drag, teclas cuando tiene foco) y es ideal para lógica específica de UI.

```python
extends Button

func _gui_input(event):
    if event is InputEventMouseButton and event.pressed:
        if event.button_index == MOUSE_BUTTON_LEFT:
            print("Click izquierdo sobre el botón")
```

- La gran diferencia frente a **`_input`** es que **`_gui_input`** se dispara solo cuando el ratón o el teclado interactúan con ese control concreto (respetando el orden de la UI, focus, etc.).

---

## Flujo de eventos en presencia de UI

De forma simplificada:

1. El evento entra en la capa de UI.
2. Los **`Control`** relevantes tienen oportunidad de procesarlo vía **`_gui_input(event)`**.
3. Si un control “consume” el evento (por ejemplo, un botón que se clickea), este no seguirá al resto de la cadena.
4. Después de eso, los eventos que no fueron consumidos pasan a **`_unhandled_input(event)`** en los nodos del árbol de juego.

Esto permite que:

- Clics en botones no disparen al mismo tiempo disparos del personaje.
- Las teclas de navegación de menús funcionen sin interferir con el gameplay.

---

## Ejemplo: botón de pausa que no dispara el arma

```python
# Nodo Button dentro de la UI
extends Button

func _gui_input(event):
    if event is InputEventMouseButton and event.pressed:
        if event.button_index == MOUSE_BUTTON_LEFT:
            get_tree().paused = not get_tree().paused
            accept_event()  # Marca el evento como consumido
```

```python
# Nodo Player
extends CharacterBody2D

func _unhandled_input(event):
    if event.is_action_pressed("shoot"):
        shoot()
```

- El botón de pausa llama **`accept_event()`** para marcar el evento como consumido.
- Como el click ya fue consumido por la UI, no llega a **`_unhandled_input`** del jugador y no se dispara el arma.

---

## Foco de teclado en la UI

- Los nodos **`Control`** pueden tener foco (focus) y recibir eventos de teclado sin necesidad de ratón.
- Propiedades como **`focus_mode`** y métodos como **`grab_focus()`** controlan qué elemento recibe las teclas (por ejemplo, al navegar con **`ui_up`**, **`ui_down`**, **`ui_accept`**).
- Esto es clave para menús navegables con mando o teclado sin usar el ratón.